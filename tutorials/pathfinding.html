<!DOCTYPE html>
<html>
<head>
	<title>Canvace</title>
	<link href="http://fonts.googleapis.com/css?family=Titillium+Web:300" rel="stylesheet" type="text/css">
	<link href="/css/screen.css" rel="stylesheet" type="text/css" media="screen" />
	<link href="/pygments.css" rel="stylesheet" type="text/css" />
</head>
<body>

<header class="header">
    Header here
</header>

<a href="https://github.com/canvace"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>

<div class="contents">
<h1 id='pathfinding_with_canvace'>Pathfinding with Canvace</h1>

<p>This chapter describes how you can use Canvace to move entities efficiently around your map. Keep in mind entities can move only on non-solid tiles: paths generated by Canvace always avoid stepping on a solid tile.</p>

<p>Moving an entity requires two phases:</p>

<ul>
<li>the path, if one is present, is computed by Canvace using the A* algorithm, and returned as a list of tile coordinates;</li>

<li>the single steps of the path are carried out in sequence.</li>
</ul>

<p>Let&#8217;s first explain how the path computation is implemented:</p>
<div class='highlight'><pre><code class='javascript'>    <span class='kd'>var</span> <span class='nx'>instance</span> <span class='o'>=</span> <span class='nx'>stage</span><span class='p'>.</span><span class='nx'>getInstance</span><span class='p'>(</span> <span class='p'>{</span> <span class='nx'>name</span><span class='o'>:</span> <span class='nx'>n</span> <span class='p'>}</span> <span class='p'>);</span>
    <span class='p'>...</span>
    <span class='kd'>var</span> <span class='nx'>currentPos</span> <span class='o'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='nx'>instance</span><span class='p'>.</span><span class='nx'>getPosition</span><span class='p'>();</span>
    <span class='kd'>var</span> <span class='nx'>map</span> <span class='o'>=</span> <span class='nx'>stage</span><span class='p'>.</span><span class='nx'>getTileMap</span><span class='p'>();</span>
    <span class='kd'>var</span> <span class='nx'>astarNode</span> <span class='o'>=</span> <span class='nx'>map</span><span class='p'>.</span><span class='nx'>getGraphNode</span><span class='p'>(</span><span class='nb'>Math</span><span class='p'>.</span><span class='nx'>round</span><span class='p'>(</span><span class='nx'>currentPos</span><span class='p'>.</span><span class='nx'>i</span><span class='p'>),</span> <span class='nb'>Math</span><span class='p'>.</span><span class='nx'>round</span><span class='p'>(</span><span class='nx'>currentPos</span><span class='p'>.</span><span class='nx'>j</span><span class='p'>),</span> <span class='nx'>LAYER</span><span class='p'>,</span> <span class='nx'>destination</span><span class='p'>.</span><span class='nx'>i</span><span class='p'>,</span> <span class='nx'>destination</span><span class='p'>.</span><span class='nx'>j</span><span class='p'>);</span>
    <span class='k'>this</span><span class='p'>.</span><span class='nx'>pathTiles</span> <span class='o'>=</span> <span class='nx'>map</span><span class='p'>.</span><span class='nx'>findPath</span><span class='p'>(</span><span class='nx'>astarNode</span><span class='p'>);</span>
</code></pre></div>
<p>Line 1 gets the default instance of the interested entity: read the chapter about entities to see why this is necessary.</p>

<p>In order for the A* algorithm to find a path, we need a representation of the stage map as a graph where each tile is a node, and an edge exists between two tiles when they are adjacent in the map. The <code>findPath()</code> method of <code>Canvace.Astar</code> requires a <code>Canvace.Astar.Node</code> object which contains all the needed graph information. The <code>getGraphNode()</code> method takes the current position and the desired destination, and returns such object. The layer needs to be passed only once, as the graph stored inside Canvace allows no connections between tiles on different layers.</p>

<p>When no path exists, <code>findPath()</code> returns NULL. Otherwise, it returns an array of (i, j) pairs, each containing the map coordinates of a non-solid tile. Concatenating all these tiles together in the same order as they appear in the array, we get the computed path (starting tile excluded).</p>
<div class='highlight'><pre><code class='javascript'>    <span class='k'>this</span><span class='p'>.</span><span class='nx'>interpolationStep</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>duration</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='kd'>var</span> <span class='nx'>nextTile</span> <span class='o'>=</span> <span class='k'>this</span><span class='p'>.</span><span class='nx'>pathTiles</span><span class='p'>.</span><span class='nx'>shift</span><span class='p'>();</span>
        
        <span class='nx'>animator</span><span class='p'>.</span><span class='nx'>interpolatePosition</span><span class='p'>(</span><span class='k'>this</span><span class='p'>.</span><span class='nx'>instance</span><span class='p'>,</span> <span class='p'>{</span>
            <span class='nx'>i</span><span class='o'>:</span> <span class='nx'>nextTile</span><span class='p'>.</span><span class='nx'>i</span><span class='p'>,</span>
            <span class='nx'>j</span><span class='o'>:</span> <span class='nx'>nextTile</span><span class='p'>.</span><span class='nx'>j</span>
        <span class='p'>},</span> <span class='nx'>duration</span><span class='p'>,</span> <span class='p'>{</span>
            <span class='nx'>callback</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span>
                <span class='c1'>// called when interpolation is finished</span>
            <span class='p'>}</span>
        <span class='p'>});</span>

        <span class='k'>if</span> <span class='p'>(</span><span class='k'>this</span><span class='p'>.</span><span class='nx'>pathTiles</span><span class='p'>.</span><span class='nx'>length</span> <span class='o'>===</span> <span class='mi'>0</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='c1'>// we reached the destination node.</span>
        <span class='p'>}</span>
    <span class='p'>};</span>
</code></pre></div>
<p>The actual movement from one tile to the next is performed as an interpolated animation. Such animations may influence the entity&#8217;s position, velocity and acceleration vectors. After changing the vectors, the entity position must be updated: this is done automatically by Canvace only if the entity&#8217;s physics is enabled. Otherwise, you must manually call the <code>update()</code> method for the affected instance.</p>

<p>In the above snippet, each invokation to <code>interpolationStep()</code> starts an animation which moves the entity instance from the current position to the next tile of the path. You can specify the duration in milliseconds of the animation with the third parameter, controlling the speed of your entity. The <code>interpolatePosition()</code> method performs a linear interpolation between the two consecutive positions: the effect is that the entity will move from the current position to the destination at constant speed. It is however possible to specify a more complex pattern of movement: this is done by setting the <code>easing</code> property of the last parameter. The <code>Canvace.Animator.Easing</code> class provides a set of pre-defined easing methods; alternatively, you can define and pass your own function.</p>

<p>Although this code snippet doesn&#8217;t show it, additional code prevents an interpolation step from being started before the previous one has finished: overlapping more animations on the same entity instance easily causes errors, and the resulting path may be different from the one computed by A*.</p>
<hr />
</div>

<footer class="footer">
    Footer here
</footer>

</body>
</html>
