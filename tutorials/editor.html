<!DOCTYPE html>
<html>
<head>
	<title>Canvace</title>
	<link rel="stylesheet" type="text/css" href="Style.css"/>
	<link rel="stylesheet" type="text/css" href="pygments.css" />
</head>
<body>
	<a href="https://github.com/canvace"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
<h1 id='the_development_environment'>The development environment</h1>

<p>In this chapter, I will explain how to use the development environment provided by Canvace to set up a single level for an isometric game. Once Canvace has been installed and the webserver is running, the environment is accessed by pointing your browser to <code>http://localhost/DevEnv</code></p>

<p>The first step is creating a new stage using <strong>Create stage</strong>. Each stage represents one level in the game. Click on the newly-created stage in the list to open the editor.</p>

<h2 id='projection_matrix'>Projection matrix</h2>

<p>When creating a new stage, the projection matrix needs to be defined. You can either select the default one, or enter a customized 3x3 matrix. For isometric games, the default projection matrix transforms the 3d map coordinates of the elements (in Canvace referred to as i, j and k) into window coordinates for the canvas (x, y and z, where the depth z is used to avoid drawing objects hidden by closer ones).</p>

<p>When using the default projection matrix, an issue may arise. Consider two adjacent tiles and an entity as in the following figure (seen from above):</p>

<p><img alt='Tiles' src='isometric.png' /></p>

<p>The point identifies the location of the entity, but the entity frame actually spawns across the two tiles (circle around the point). With the default projection matrix, the canvas z coordinate is computed as a sum of the i, j and k coordinates. You can see Tile1 and Tile2 have the same j and k coordinate, but Tile1 has an higher i coordinate. Therefore, when the canvas content is rendered, Tile1 is regarded as being placed behind Tile2. If an entity frame occupies both Tile1 and Tile2, the section on Tile1 will be hidden, resulting in the ugly effect shown below:</p>

<p>SCREEN OF EFFECT</p>

<p>In order to avoid this, pavement tiles must be configured and stamped as roof of a layer placed below the default one. Graphically speaking, nothing changes, but the issue is solved, because now both tiles have a lower k coordinate, different from that of the entity.</p>

<h2 id='editing_the_game_environment'>Editing the game environment</h2>

<p>SCREENSHOT OF EDITOR</p>

<p>All the pictures used for the game environment and characters have to be first imported in the editor. This is done in the tab <strong>Images</strong> of the lower panel.</p>

<p>SCREENSHOT OF LOWER PANEL, IMAGES TAB</p>

<p>Select <strong>Import images</strong>. This opens the import dialog, where you can import images from the hard drive. It&#8217;s quite useful to group together images belonging to the same category by assigning them one or more comma-separated labels. Next, we need to create tiles, which will form the ground or floor of our game map.</p>

<p>SCREENSHOT OF TILES TAB</p>

<p>A tile can be created by choosing the <strong>Create new tile</strong> button. First, we keep the default dimension for tiles: in our game, each tile spawns over a single map square.</p>

<p>SCREEN OF FIRST OPTIONS</p>

<p>Whether a tile is solid or not influences the feasible movements of our units: therefore, all tiles containing buildings or grass are solid, whereas for road tiles we disable this option, as we want our characters to be able to move on them. To define the appearance of the tile, we add a frame to it. When adding a frame, you can choose the picture that represents it; this is where labeled images come in handy, since you can choose to view only the images belonging to certain categories. For example, for tiles we used only pictures labeled as &#8220;world,ground&#8221;.</p>

<p>SCREENSHOT OF DIALOG WITH FRAMES</p>

<p>No additional properties are needed for our game, and so we close the dialog. These settings can however be modified later by double-clicking on the tile in the list. After the tiles have been created, we set up a little &#8220;town&#8221; by adding them to the map. This is done by selecting the desired tile, and then the <strong>Stamp tile</strong> drawing tool. It is now possible to &#8220;stamp&#8221; tiles around the game map. You may notice it is possible to stamp a tile on top of an existent one: the newer one will simply overwrite it. It is also possible to erase tiles from the map (restoring a blank square) with the eraser tools.</p>

<p>Now that the generic environment has been designed, we add our game characters as <strong>Entities</strong>. Entities (unlike tiles) aren&#8217;t bounded in specific map squares, but they can appear in any point of the map, and can be moved around as the game progresses. Apart from this, the creation process is quite similar to the one we followed for tiles: a new entity is created and a picture is associated to it. Additionally, in the setting panel, the physics has been enabled for every entity. This is useful when developing the game logic, as it gives quick and easy access to a set of features that control the movements of the entities.</p>

<p>SCREEN WITH PHYSICS</p>

<p>As above, entities can be stamped in the desired positions with <strong>Stamp entity</strong>, and subsequently erased. Entities can also be moved around using the <strong>Move entity</strong> drawing tool. This is the final appearance of the game level:</p>

<p>FINAL SCREEN</p>

<p>Looking at the right panel, you may notice there are actually two layers here: &#8220;layer 0&#8221;, the default ones, contains the tiles, while &#8220;layer 1&#8221; contains the entities. This is a trick employed in order to avoid the issues with isometric games described in the introduction of this tutorial. Layers of course can be created also to make a game extend on the third dimension.</p>

<p>The changes made to the stage are saved using the &#8220;Save&#8221; button. As soon as the level environment is completed and saved, it needs to be exported in a format recognizable by Canvace. This is done in the <strong>Stage</strong> bar: specifically, &#8220;Download images&#8221; exports all the pictures used in an archive, while &#8220;Download JSON&#8221; exports a JSON file containing the stage information, found HERE.</p>
<hr />
</body>
</html>
